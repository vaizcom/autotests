{"uid":"18f16478c9a839c2","name":"Получение списка недавних Space-документов ролью member","fullName":"tests.test_backend.document.access_doc.test_get_recent_documents_access_by_roles#test_get_recent_documents_access_by_roles","historyId":"b1c858c3b8ed1d4e467942bf83358e7a","time":{"start":1753090071301,"stop":1753090080378,"duration":9077},"description":"\n    Проверяем доступ к списку недавних документов для ролей owner, manager, member, guest.\n    Создаются тестовые документы, проверяется их доступность\n    и корректный порядок отображения после повторной маркировки.\n    ","descriptionHtml":"<pre><code>Проверяем доступ к списку недавних документов для ролей owner, manager, member, guest.\nСоздаются тестовые документы, проверяется их доступность\nи корректный порядок отображения после повторной маркировки.\n</code></pre>\n","status":"failed","statusMessage":"AssertionError: Порядок документов после повторной маркировки неверный\nassert ['687e0817a27...2adaed0', ...] == ['687e0819a27...2adaea6', ...]\n  \n  At index 0 diff: '687e0817a27240a982adae65' != '687e0819a27240a982adaf0c'\n  \n  Full diff:\n    [\n  +     '687e0817a27240a982adae65',\n  +     '687e0817a27240a982adae7b',\n  +     '687e0818a27240a982adae91',\n  +     '687e0818a27240a982adaea6',\n  +     '687e0818a27240a982adaebb',\n  +     '687e0818a27240a982adaed0',\n  +     '687e0819a27240a982adaee4',\n  +     '687e0819a27240a982adaef8',\n        '687e0819a27240a982adaf0c',\n  -     '687e0819a27240a982adaef8',\n  -     '687e0819a27240a982adaee4',\n  -     '687e0818a27240a982adaed0',\n  -     '687e0818a27240a982adaebb',\n  -     '687e0818a27240a982adaea6',\n  -     '687e0818a27240a982adae91',\n  -     '687e0817a27240a982adae7b',\n  -     '687e0817a27240a982adae65',\n    ]","statusTrace":"request = <FixtureRequest for <Function test_get_recent_documents_access_by_roles[space_docs-member]>>\nmain_space = '6866309d85fb8d104544a61e', client_fixture = 'member_client'\nexpected_status = 200, kind = 'Space', container_fixture = 'main_space'\n\n    @pytest.mark.parametrize(\n        'client_fixture, expected_status',\n        [\n            ('owner_client', 200),\n            ('manager_client', 200),\n            ('member_client', 200),\n            ('guest_client', 200),\n        ],\n        ids=['owner', 'manager', 'member', 'guest']\n    )\n    @pytest.mark.parametrize(\n        'kind, container_fixture',\n        [\n            ('Space', 'main_space'),\n            ('Project', 'main_project'),\n        ],\n        ids=['space_docs', 'project_docs'],\n    )\n    def test_get_recent_documents_access_by_roles(\n        request,\n        main_space,\n        client_fixture,\n        expected_status,\n        kind,\n        container_fixture\n    ):\n        \"\"\"\n        Проверяем доступ к списку недавних документов для ролей owner, manager, member, guest.\n        Создаются тестовые документы, проверяется их доступность\n        и корректный порядок отображения после повторной маркировки.\n        \"\"\"\n        api_client = request.getfixturevalue(client_fixture)\n        role = client_fixture.replace('_client', '')\n        container_id = request.getfixturevalue(container_fixture)\n        EXPECTED_DOCS_COUNT = 9\n    \n        allure.dynamic.title(f'Получение списка недавних {kind}-документов ролью {role}')\n    \n        created_docs = []\n    \n        with allure.step(f'Создание {EXPECTED_DOCS_COUNT} тестовых {kind}-документов'):\n            # Создаем по 3 документа от каждой роли\n            for creator_role in ['owner', 'manager', 'member']:\n                creator = request.getfixturevalue(f'{creator_role}_client')\n                for i in range(3):\n                    title = f\"Recent document {i+1} by {creator_role}\"\n                    create_resp = creator.post(\n                        **create_document_endpoint(\n                            kind=kind,\n                            kind_id=container_id,\n                            space_id=main_space,\n                            title=title\n                        )\n                    )\n                    assert create_resp.status_code == 200, (\n                        f'Ошибка при создании документа: статус {create_resp.status_code}'\n                    )\n                    doc_id = create_resp.json()['payload']['document']['_id']\n                    created_docs.append({\n                        'id': doc_id,\n                        'title': title,\n                        'creator': creator,\n                        'creator_role': creator_role\n                    })\n    \n        try:\n            docs_count = len(created_docs)\n            assert docs_count == EXPECTED_DOCS_COUNT, (\n                f'Неверное количество созданных документов: {docs_count}, ожидалось: {EXPECTED_DOCS_COUNT}'\n            )\n    \n            with allure.step('Маркировка документов как недавних'):\n                for doc in created_docs:\n                    mark_resp = api_client.post(\n                        **mark_recent_document_endpoint(document_id=doc['id'], space_id=main_space)\n                    )\n                    assert mark_resp.status_code == 200, (\n                        f'Не удалось пометить документ {doc[\"id\"]} как недавний: '\n                        f'статус {mark_resp.status_code}'\n                    )\n    \n            with allure.step(f'Получение списка недавних документов ролью {role}'):\n                recent_resp = api_client.post(**get_recent_documents_endpoint(space_id=main_space))\n                assert recent_resp.status_code == expected_status\n    \n                if expected_status == 200:\n                    recent_docs = recent_resp.json()['payload']['recentDocuments']\n    \n                    with allure.step('Проверка структуры и содержимого ответа'):\n                        assert isinstance(recent_docs, list), 'recentDocuments должен быть списком'\n                        assert recent_docs, 'Список недавних документов не должен быть пустым'\n                        received_count = len(recent_docs)\n                        assert received_count == EXPECTED_DOCS_COUNT, (\n                            f'Неверное количество документов в ответе: {received_count}, '\n                            f'ожидалось: {EXPECTED_DOCS_COUNT}'\n                        )\n    \n                        recent_doc_ids = {doc['_id'] for doc in recent_docs}\n                        created_doc_ids = {doc['id'] for doc in created_docs}\n                        missing_docs = created_doc_ids - recent_doc_ids\n                        assert not missing_docs, (\n                            f'Не все документы найдены в списке недавних. '\n                            f'Отсутствуют документы с ID: {missing_docs}'\n                        )\n    \n                        required_fields = {'_id', 'title', 'kind'}\n                        for doc in recent_docs:\n                            missing_fields = required_fields - doc.keys()\n                            assert not missing_fields, f'Отсутствуют обязательные поля: {missing_fields}'\n    \n                        # Проверяем порядок документов только если создано ожидаемое количество\n                        if received_count == EXPECTED_DOCS_COUNT:\n                            original_ids = [doc['_id'] for doc in recent_docs]\n    \n                            with allure.step('Повторная маркировка документов для проверки порядка'):\n                                for doc in recent_docs[::-1]:\n                                    mark_resp = api_client.post(\n                                        **mark_recent_document_endpoint(document_id=doc['_id'], space_id=main_space)\n                                    )\n                                    assert mark_resp.status_code == 200\n    \n                            updated_resp = api_client.post(**get_recent_documents_endpoint(space_id=main_space))\n                            updated_docs = updated_resp.json()['payload']['recentDocuments']\n                            updated_ids = [doc['_id'] for doc in updated_docs]\n    \n                            # TODO: BUG: APP-3037 mark_recent_document_endpoint не перемещает документ на верх списка recent\n                            # Когда баг будет исправлен — ожидаем, что порядок изменится на обратный:\n                            # assert updated_ids == original_ids[::-1]\n                            # Пока баг не исправлен, этот ассерт падает — оставляем для контроля\n>                           assert updated_ids == original_ids[::-1], (\n                                'Порядок документов после повторной маркировки неверный'\n                            )\nE                           AssertionError: Порядок документов после повторной маркировки неверный\nE                           assert ['687e0817a27...2adaed0', ...] == ['687e0819a27...2adaea6', ...]\nE                             \nE                             At index 0 diff: '687e0817a27240a982adae65' != '687e0819a27240a982adaf0c'\nE                             \nE                             Full diff:\nE                               [\nE                             +     '687e0817a27240a982adae65',\nE                             +     '687e0817a27240a982adae7b',\nE                             +     '687e0818a27240a982adae91',\nE                             +     '687e0818a27240a982adaea6',\nE                             +     '687e0818a27240a982adaebb',\nE                             +     '687e0818a27240a982adaed0',\nE                             +     '687e0819a27240a982adaee4',\nE                             +     '687e0819a27240a982adaef8',\nE                                   '687e0819a27240a982adaf0c',\nE                             -     '687e0819a27240a982adaef8',\nE                             -     '687e0819a27240a982adaee4',\nE                             -     '687e0818a27240a982adaed0',\nE                             -     '687e0818a27240a982adaebb',\nE                             -     '687e0818a27240a982adaea6',\nE                             -     '687e0818a27240a982adae91',\nE                             -     '687e0817a27240a982adae7b',\nE                             -     '687e0817a27240a982adae65',\nE                               ]\n\ntests/test_backend/document/access_doc/test_get_recent_documents_access_by_roles.py:142: AssertionError","flaky":false,"newFailed":true,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_verify_url","time":{"start":1753089877938,"stop":1753089877938,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"base_url","time":{"start":1753089877938,"stop":1753089877938,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"delete_output_dir","time":{"start":1753089877938,"stop":1753089877938,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"pytestconfig","time":{"start":1753089877938,"stop":1753089877938,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"owner_client","time":{"start":1753089877938,"stop":1753089878403,"duration":465},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"main_client","time":{"start":1753089900396,"stop":1753089900848,"duration":452},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"main_space","time":{"start":1753089900848,"stop":1753089901104,"duration":256},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"manager_client","time":{"start":1753089901769,"stop":1753089902237,"duration":468},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"member_client","time":{"start":1753089902237,"stop":1753089902709,"duration":472},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false}],"testStage":{"description":"\n    Проверяем доступ к списку недавних документов для ролей owner, manager, member, guest.\n    Создаются тестовые документы, проверяется их доступность\n    и корректный порядок отображения после повторной маркировки.\n    ","status":"failed","statusMessage":"AssertionError: Порядок документов после повторной маркировки неверный\nassert ['687e0817a27...2adaed0', ...] == ['687e0819a27...2adaea6', ...]\n  \n  At index 0 diff: '687e0817a27240a982adae65' != '687e0819a27240a982adaf0c'\n  \n  Full diff:\n    [\n  +     '687e0817a27240a982adae65',\n  +     '687e0817a27240a982adae7b',\n  +     '687e0818a27240a982adae91',\n  +     '687e0818a27240a982adaea6',\n  +     '687e0818a27240a982adaebb',\n  +     '687e0818a27240a982adaed0',\n  +     '687e0819a27240a982adaee4',\n  +     '687e0819a27240a982adaef8',\n        '687e0819a27240a982adaf0c',\n  -     '687e0819a27240a982adaef8',\n  -     '687e0819a27240a982adaee4',\n  -     '687e0818a27240a982adaed0',\n  -     '687e0818a27240a982adaebb',\n  -     '687e0818a27240a982adaea6',\n  -     '687e0818a27240a982adae91',\n  -     '687e0817a27240a982adae7b',\n  -     '687e0817a27240a982adae65',\n    ]","statusTrace":"request = <FixtureRequest for <Function test_get_recent_documents_access_by_roles[space_docs-member]>>\nmain_space = '6866309d85fb8d104544a61e', client_fixture = 'member_client'\nexpected_status = 200, kind = 'Space', container_fixture = 'main_space'\n\n    @pytest.mark.parametrize(\n        'client_fixture, expected_status',\n        [\n            ('owner_client', 200),\n            ('manager_client', 200),\n            ('member_client', 200),\n            ('guest_client', 200),\n        ],\n        ids=['owner', 'manager', 'member', 'guest']\n    )\n    @pytest.mark.parametrize(\n        'kind, container_fixture',\n        [\n            ('Space', 'main_space'),\n            ('Project', 'main_project'),\n        ],\n        ids=['space_docs', 'project_docs'],\n    )\n    def test_get_recent_documents_access_by_roles(\n        request,\n        main_space,\n        client_fixture,\n        expected_status,\n        kind,\n        container_fixture\n    ):\n        \"\"\"\n        Проверяем доступ к списку недавних документов для ролей owner, manager, member, guest.\n        Создаются тестовые документы, проверяется их доступность\n        и корректный порядок отображения после повторной маркировки.\n        \"\"\"\n        api_client = request.getfixturevalue(client_fixture)\n        role = client_fixture.replace('_client', '')\n        container_id = request.getfixturevalue(container_fixture)\n        EXPECTED_DOCS_COUNT = 9\n    \n        allure.dynamic.title(f'Получение списка недавних {kind}-документов ролью {role}')\n    \n        created_docs = []\n    \n        with allure.step(f'Создание {EXPECTED_DOCS_COUNT} тестовых {kind}-документов'):\n            # Создаем по 3 документа от каждой роли\n            for creator_role in ['owner', 'manager', 'member']:\n                creator = request.getfixturevalue(f'{creator_role}_client')\n                for i in range(3):\n                    title = f\"Recent document {i+1} by {creator_role}\"\n                    create_resp = creator.post(\n                        **create_document_endpoint(\n                            kind=kind,\n                            kind_id=container_id,\n                            space_id=main_space,\n                            title=title\n                        )\n                    )\n                    assert create_resp.status_code == 200, (\n                        f'Ошибка при создании документа: статус {create_resp.status_code}'\n                    )\n                    doc_id = create_resp.json()['payload']['document']['_id']\n                    created_docs.append({\n                        'id': doc_id,\n                        'title': title,\n                        'creator': creator,\n                        'creator_role': creator_role\n                    })\n    \n        try:\n            docs_count = len(created_docs)\n            assert docs_count == EXPECTED_DOCS_COUNT, (\n                f'Неверное количество созданных документов: {docs_count}, ожидалось: {EXPECTED_DOCS_COUNT}'\n            )\n    \n            with allure.step('Маркировка документов как недавних'):\n                for doc in created_docs:\n                    mark_resp = api_client.post(\n                        **mark_recent_document_endpoint(document_id=doc['id'], space_id=main_space)\n                    )\n                    assert mark_resp.status_code == 200, (\n                        f'Не удалось пометить документ {doc[\"id\"]} как недавний: '\n                        f'статус {mark_resp.status_code}'\n                    )\n    \n            with allure.step(f'Получение списка недавних документов ролью {role}'):\n                recent_resp = api_client.post(**get_recent_documents_endpoint(space_id=main_space))\n                assert recent_resp.status_code == expected_status\n    \n                if expected_status == 200:\n                    recent_docs = recent_resp.json()['payload']['recentDocuments']\n    \n                    with allure.step('Проверка структуры и содержимого ответа'):\n                        assert isinstance(recent_docs, list), 'recentDocuments должен быть списком'\n                        assert recent_docs, 'Список недавних документов не должен быть пустым'\n                        received_count = len(recent_docs)\n                        assert received_count == EXPECTED_DOCS_COUNT, (\n                            f'Неверное количество документов в ответе: {received_count}, '\n                            f'ожидалось: {EXPECTED_DOCS_COUNT}'\n                        )\n    \n                        recent_doc_ids = {doc['_id'] for doc in recent_docs}\n                        created_doc_ids = {doc['id'] for doc in created_docs}\n                        missing_docs = created_doc_ids - recent_doc_ids\n                        assert not missing_docs, (\n                            f'Не все документы найдены в списке недавних. '\n                            f'Отсутствуют документы с ID: {missing_docs}'\n                        )\n    \n                        required_fields = {'_id', 'title', 'kind'}\n                        for doc in recent_docs:\n                            missing_fields = required_fields - doc.keys()\n                            assert not missing_fields, f'Отсутствуют обязательные поля: {missing_fields}'\n    \n                        # Проверяем порядок документов только если создано ожидаемое количество\n                        if received_count == EXPECTED_DOCS_COUNT:\n                            original_ids = [doc['_id'] for doc in recent_docs]\n    \n                            with allure.step('Повторная маркировка документов для проверки порядка'):\n                                for doc in recent_docs[::-1]:\n                                    mark_resp = api_client.post(\n                                        **mark_recent_document_endpoint(document_id=doc['_id'], space_id=main_space)\n                                    )\n                                    assert mark_resp.status_code == 200\n    \n                            updated_resp = api_client.post(**get_recent_documents_endpoint(space_id=main_space))\n                            updated_docs = updated_resp.json()['payload']['recentDocuments']\n                            updated_ids = [doc['_id'] for doc in updated_docs]\n    \n                            # TODO: BUG: APP-3037 mark_recent_document_endpoint не перемещает документ на верх списка recent\n                            # Когда баг будет исправлен — ожидаем, что порядок изменится на обратный:\n                            # assert updated_ids == original_ids[::-1]\n                            # Пока баг не исправлен, этот ассерт падает — оставляем для контроля\n>                           assert updated_ids == original_ids[::-1], (\n                                'Порядок документов после повторной маркировки неверный'\n                            )\nE                           AssertionError: Порядок документов после повторной маркировки неверный\nE                           assert ['687e0817a27...2adaed0', ...] == ['687e0819a27...2adaea6', ...]\nE                             \nE                             At index 0 diff: '687e0817a27240a982adae65' != '687e0819a27240a982adaf0c'\nE                             \nE                             Full diff:\nE                               [\nE                             +     '687e0817a27240a982adae65',\nE                             +     '687e0817a27240a982adae7b',\nE                             +     '687e0818a27240a982adae91',\nE                             +     '687e0818a27240a982adaea6',\nE                             +     '687e0818a27240a982adaebb',\nE                             +     '687e0818a27240a982adaed0',\nE                             +     '687e0819a27240a982adaee4',\nE                             +     '687e0819a27240a982adaef8',\nE                                   '687e0819a27240a982adaf0c',\nE                             -     '687e0819a27240a982adaef8',\nE                             -     '687e0819a27240a982adaee4',\nE                             -     '687e0818a27240a982adaed0',\nE                             -     '687e0818a27240a982adaebb',\nE                             -     '687e0818a27240a982adaea6',\nE                             -     '687e0818a27240a982adae91',\nE                             -     '687e0817a27240a982adae7b',\nE                             -     '687e0817a27240a982adae65',\nE                               ]\n\ntests/test_backend/document/access_doc/test_get_recent_documents_access_by_roles.py:142: AssertionError","steps":[{"name":"Создание 9 тестовых Space-документов","time":{"start":1753090071301,"stop":1753090073656,"duration":2355},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"Маркировка документов как недавних","time":{"start":1753090073656,"stop":1753090075549,"duration":1893},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"Получение списка недавних документов ролью member","time":{"start":1753090075549,"stop":1753090077797,"duration":2248},"status":"failed","statusMessage":"AssertionError: Порядок документов после повторной маркировки неверный\nassert ['687e0817a27...2adaed0', ...] == ['687e0819a27...2adaea6', ...]\n  \n  At index 0 diff: '687e0817a27240a982adae65' != '687e0819a27240a982adaf0c'\n  \n  Full diff:\n    [\n  +     '687e0817a27240a982adae65',\n  +     '687e0817a27240a982adae7b',\n  +     '687e0818a27240a982adae91',\n  +     '687e0818a27240a982adaea6',\n  +     '687e0818a27240a982adaebb',\n  +     '687e0818a27240a982adaed0',\n  +     '687e0819a27240a982adaee4',\n  +     '687e0819a27240a982adaef8',\n        '687e0819a27240a982adaf0c',\n  -     '687e0819a27240a982adaef8',\n  -     '687e0819a27240a982adaee4',\n  -     '687e0818a27240a982adaed0',\n  -     '687e0818a27240a982adaebb',\n  -     '687e0818a27240a982adaea6',\n  -     '687e0818a27240a982adae91',\n  -     '687e0817a27240a982adae7b',\n  -     '687e0817a27240a982adae65',\n    ]\n","statusTrace":"  File \"/home/runner/work/autotests/autotests/tests/test_backend/document/access_doc/test_get_recent_documents_access_by_roles.py\", line 142, in test_get_recent_documents_access_by_roles\n    assert updated_ids == original_ids[::-1], (\n","steps":[{"name":"Проверка структуры и содержимого ответа","time":{"start":1753090075758,"stop":1753090077796,"duration":2038},"status":"failed","statusMessage":"AssertionError: Порядок документов после повторной маркировки неверный\nassert ['687e0817a27...2adaed0', ...] == ['687e0819a27...2adaea6', ...]\n  \n  At index 0 diff: '687e0817a27240a982adae65' != '687e0819a27240a982adaf0c'\n  \n  Full diff:\n    [\n  +     '687e0817a27240a982adae65',\n  +     '687e0817a27240a982adae7b',\n  +     '687e0818a27240a982adae91',\n  +     '687e0818a27240a982adaea6',\n  +     '687e0818a27240a982adaebb',\n  +     '687e0818a27240a982adaed0',\n  +     '687e0819a27240a982adaee4',\n  +     '687e0819a27240a982adaef8',\n        '687e0819a27240a982adaf0c',\n  -     '687e0819a27240a982adaef8',\n  -     '687e0819a27240a982adaee4',\n  -     '687e0818a27240a982adaed0',\n  -     '687e0818a27240a982adaebb',\n  -     '687e0818a27240a982adaea6',\n  -     '687e0818a27240a982adae91',\n  -     '687e0817a27240a982adae7b',\n  -     '687e0817a27240a982adae65',\n    ]\n","statusTrace":"  File \"/home/runner/work/autotests/autotests/tests/test_backend/document/access_doc/test_get_recent_documents_access_by_roles.py\", line 142, in test_get_recent_documents_access_by_roles\n    assert updated_ids == original_ids[::-1], (\n","steps":[{"name":"Повторная маркировка документов для проверки порядка","time":{"start":1753090075758,"stop":1753090077597,"duration":1839},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":1,"attachmentsCount":0,"hasContent":true}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":2,"attachmentsCount":0,"hasContent":true},{"name":"Удаление тестовых документов","time":{"start":1753090077797,"stop":1753090080378,"duration":2581},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":6,"attachmentsCount":0,"hasContent":true},"afterStages":[],"labels":[{"name":"tag","value":"backend"},{"name":"parentSuite","value":"tests.test_backend.document.access_doc"},{"name":"suite","value":"test_get_recent_documents_access_by_roles"},{"name":"host","value":"pkrvmq0rgcvqdmg"},{"name":"thread","value":"2528-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_backend.document.access_doc.test_get_recent_documents_access_by_roles"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"client_fixture","value":"'member_client'"},{"name":"container_fixture","value":"'main_space'"},{"name":"expected_status","value":"200"},{"name":"kind","value":"'Space'"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":1,"broken":0,"skipped":0,"passed":4,"unknown":0,"total":5},"items":[{"uid":"d2ec9ad1f2cb88fd","reportUrl":"https://vaizcom.github.io/autotests/314//#testresult/d2ec9ad1f2cb88fd","status":"passed","time":{"start":1752836962414,"stop":1752836973138,"duration":10724}},{"uid":"113ce2aeddda929a","reportUrl":"https://vaizcom.github.io/autotests/313//#testresult/113ce2aeddda929a","status":"passed","time":{"start":1752836086835,"stop":1752836096696,"duration":9861}},{"uid":"662b9ca1f4f78645","reportUrl":"https://vaizcom.github.io/autotests/312//#testresult/662b9ca1f4f78645","status":"passed","time":{"start":1752827405287,"stop":1752827407144,"duration":1857}},{"uid":"d9bddb53ecfe8619","reportUrl":"https://vaizcom.github.io/autotests/311//#testresult/d9bddb53ecfe8619","status":"passed","time":{"start":1752738341457,"stop":1752738343463,"duration":2006}}]},"tags":["backend"]},"source":"18f16478c9a839c2.json","parameterValues":["'member_client'","'main_space'","200","'Space'"]}